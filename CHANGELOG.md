# Changelog

All notable changes to Abiqua Asset Management (AAM) will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Idempotent conversation creation with `ensureConversation()` method
  - POST `/api/conversation/create` now accepts optional `conversation_id` parameter
  - If conversation exists, returns existing conversation instead of error (idempotent behavior)
  - Backend logs whether conversation was "created" or "reused" for transparency
  - API response includes `created` boolean field for frontend logging
  - Participant validation/merging when conversation exists:
    - Ensures calling device is a participant (auto-adds if missing)
    - Adds any other participants from request that aren't already in conversation
    - Handles multi-device scenarios where different devices call ensureConversation with different participant lists
  - Frontend `ConversationApi.ensureConversation()` method guarantees conversation exists before message send
  - Blocking error banner displayed when conversation ensure fails
  - Message composer disabled when conversation error exists
- Redis-backed conversation registry for Heroku multi-dyno deployments
  - ConversationStore abstraction with Redis and InMemory implementations
  - Redis-backed storage using Heroku Redis addon (REDIS_URL)
  - Automatic fallback to in-memory store in demo mode when Redis unavailable
  - Configurable TTL for conversations (CONVERSATION_TTL_SECONDS, default: 30 minutes)
  - Conversations persist across dyno restarts and multiple dynos
  - Only conversation metadata stored (no message content, encryption keys, or decrypted payloads)
  - Enhanced logging for Redis connection status and conversation operations
  - Demo mode auto-creation of conversations in Redis when not found
  - Frontend banner warning when demo mode auto-creates conversations

### Fixed
- Critical: Missing `import copy` in conversation_store.py (would cause NameError at runtime)
- Deprecation warnings: Replaced all `datetime.utcnow()` calls with `datetime.now(UTC)` (8 instances)
  - Updated imports to include `UTC` from datetime module
  - Eliminates all deprecation warnings in conversation_store.py
- Test infrastructure improvements
  - Fixed 33 Redis configuration errors by adding `demo_mode=True` to test fixtures
  - Updated test expectations for Pydantic validation (422 instead of 400)
  - Updated test expectations for conversation_not_found (400 instead of 404)
  - Fixed test logic issue in `test_conversation_persistence_across_operations` (device-003 registration)
- Demo mode auto-participant logic
  - Automatically adds device as participant when sending to existing conversation in demo mode
  - Prevents 403 Forbidden errors in multi-device Heroku demos
  - Maintains strict security in non-demo mode
- Thread-safety improvements in InMemoryConversationStore
  - Added Lock initialization in `__init__()` for thread-safe concurrent access to in-memory store
  - All methods (get, create, update, add_participant, remove_participant, delete, exists) now use locks
  - Prevents data corruption in demo mode with concurrent users within a single process
  - `get_conversation()` returns deep copy to prevent external modification of nested structures (participants list)
  - `create_conversation()` and `update_conversation()` copy participant lists to prevent external modification
  - Added conversation state validation in add_participant (consistent with Redis implementation)
- Frontend polling optimization
  - Reduced DemoModeBanner polling interval from 1 second to 2 seconds
  - Reduces overhead while still catching same-tab localStorage updates promptly
- Critical race condition fixes in Redis conversation store
  - Fixed race conditions in `add_participant()` and `remove_participant()` using WATCH/MULTI/EXEC transactions
  - Fixed race condition in `update_conversation()` TTL preservation using optimistic locking with retry logic
  - All participant management operations now use atomic Redis transactions to prevent data corruption under concurrent access
  - Retry logic (up to 3 attempts) handles concurrent modification conflicts gracefully
  - Properly distinguishes TTL=-2 (key doesn't exist) from TTL=-1 (no expiration) to prevent silent failures
- Redis conversation store TTL handling improvements
  - Fixed TTL reset behavior: updates now preserve remaining TTL instead of resetting to full duration
  - Prevents unexpected expiration timing when conversations are updated frequently
  - Uses Redis TTL command to get remaining time before updating
  - Proper handling of TTL=-2 (key deleted) vs TTL=-1 (no expiration) scenarios
- Participant cache synchronization with Redis TTL expiration
  - Fixed cache staleness: `get_conversation_participants()` always reads from store to ensure consistency
  - Added cache invalidation when conversations expire or are deleted
  - `handle_participant_revocation()` validates conversation existence before removal (handles TTL expiration)
  - Cache is updated when conversations exist, but always verified against store
- Redis connection latency optimization
  - Removed per-operation Redis ping calls (was adding latency overhead)
  - Connection status cached, only marked as lost on actual errors
  - Added separate `_check_connection()` method for explicit health checks (startup only)
  - Redis client exceptions properly caught and connection marked as lost
- Demo mode detection API improvements
  - Added public `is_demo_mode()` method to DeviceRegistry (replaces unsafe private attribute access)
  - Updated conversation_api.py to use proper API instead of `getattr(..., '_demo_mode')`
- Frontend demo mode banner integration
  - Fixed same-tab update detection: added polling in addition to storage events (storage events only fire cross-tab)
  - Backend now sets `X-Demo-Mode-Auto-Create` header in responses when auto-creating conversations
  - Frontend checks header and sets localStorage flag with both storage events and polling
  - Banner now detects auto-creation in both same-tab and cross-tab scenarios
- Production error logging security
  - Error logging now conditional on development mode (import.meta.env.DEV)
  - Production logs only show generic errors without exposing details (conversation_id, error_code, request_id)
  - Prevents sensitive information from appearing in browser console in production
- Demo Mode for reliable Heroku multi-device demos
  - DEMO_MODE environment variable enables HTTP-first messaging
  - Device activity tracking with 5-minute TTL (devices considered "active" if seen within TTL)
  - Auto-registration of unknown devices on first request
  - Lenient device validation (does not reject message sends due to device_not_active or missing WebSocket)
  - WebSocket becomes best-effort delivery, not authorization requirement
  - Messages always queued for REST polling even if WebSocket unavailable
  - Frontend demo mode banner: "ðŸ§ª Demo Mode â€” WebSocket optional, encryption enforced"
  - Frontend does not block message sending based on WebSocket connection status in demo mode
  - Backend logs clearly indicate when demo mode logic is applied
  - Encryption requirements remain enforced (client or server mode)
  - Behavior explicitly gated behind DEMO_MODE flag (no production impact)

### Fixed
- UI conversation selection and copy button fixes
  - Fixed copy button in ConversationJoin component to show visual feedback ("Copied!" message)
  - Fixed conversation ID display to show currently selected conversation (not just joined conversation)
  - Fixed conversation selection sync: joining a conversation now automatically selects it in the UI
  - Added useEffect to sync selectedConversationId with currentConversationId when conversations are joined
  - Enhanced error logging in httpMessageApi.ts to show conversation_id, error_code, and request_id for debugging
  - Improved copy button error handling with fallback for older browsers
  - Fixes issue where messages were sent to wrong conversation after joining
- Message send endpoint contract mismatch (conversation_id handling)
  - Added Pydantic `SendMessageRequest` model to explicitly require conversation_id in request body
  - Changed conversation_not_found error from 404 to 400 Bad Request (per requirements)
  - Added logging for received conversation_id to aid debugging
  - Frontend now always includes conversation_id and encryption mode in request body
  - Frontend validates conversation_id is present before sending
  - Fixes 404 conversation_not_found errors when sending messages
- Demo mode fixes for reliable Heroku messaging
  - Fixed DEMO_MODE default to TRUE on Heroku (detected via DYNO env var - Heroku-specific, not PORT)
  - Fixed missing mark_device_seen() calls in HTTP message send endpoint
  - Fixed WebSocket handler to accept connections immediately in demo mode (no active check, never returns 403)
  - Fixed message relay to always return success in demo mode (message queued for REST polling even if WebSocket fails)
  - Fixed auto-registration error handling to verify device exists before continuing (prevents execution with missing device)
  - Updated demo mode banner text: "Messages delivered via HTTP, WebSocket optional"
  - Ensures messages are always visible on Heroku with multiple browsers
- TypeScript compilation errors in Heroku build
  - Fixed missing props destructuring in App.tsx (currentConversationId, onConversationJoined)
  - Fixed unused parameter warnings in MessagingView.tsx (deviceId) and messageApi.ts (content)
  - Prefixed unused parameters with underscore to satisfy TypeScript strict mode
  - All TypeScript errors resolved, Heroku build now succeeds
- Conversation creation endpoint (`POST /api/conversation/create`) now uses Pydantic request model
  - Replaced raw `List[str]` parameter with `CreateConversationRequest` model
  - Request body now requires `{"participants": ["device-001", "device-002"]}` format (not raw array)
  - Fixed 422 Unprocessable Content errors caused by payload shape mismatches
  - Updated to Pydantic v2 style (`model_config` instead of deprecated `Config` class)
  - OpenAPI schema now clearly documents expected payload shape
- Logging service crash fix (`logging_service.log_event`)
  - Now safely handles both `LogEventType` enum and string event types
  - Prevents `AttributeError: 'str' object has no attribute 'value'` crashes
  - Invalid event types log warnings instead of crashing the server
  - Updated `log_audit_event` to also handle string event types safely
- Conversation creation defensive error handling
  - Returns existing conversation if conversation with same ID already exists (idempotent behavior)
  - Validates empty participant lists with clear 400 error response
  - Automatically includes calling device in participants if not present
  - Returns structured error responses with `error_code`, `message`, and `request_id`
- Test fix for `test_send_message_sender_not_participant`
  - Fixed test to use unique conversation ID to avoid fixture conflicts
  - Properly registers all required test devices before creating conversation

### Added
- Message send endpoint implementation (`POST /api/message/send`) per API Contracts (#10), Section 3.3
  - Request body: `{ conversation_id: string, payload: string, expiration?: ISO timestamp }`
  - Assigns `message_id` server-side (UUID v4)
  - Uses server timestamp (not client-provided)
  - Validates required fields (conversation_id, payload)
  - Validates device exists and is ACTIVE (returns 403 if inactive)
  - Validates conversation exists (returns 404 if not found, 400 if inactive)
  - Validates sender is a participant in the conversation (returns 403 if not)
  - Enforces payload size â‰¤ 50KB
  - Validates expiration is in the future (if provided)
  - Derives expiration from server timestamp + default expiration days (if not provided)
  - Registers message in delivery state machine (PendingDelivery state)
  - Forwards message to WebSocket recipients or offline queue
  - Returns 202 Accepted with `{ message_id, timestamp, status: "queued" }`
  - Logs metadata only (no message content) per Logging & Observability (#14)
  - Uses LogEventType enum for logging (MESSAGE_ATTEMPTED, DELIVERY_FAILED)
  - Comprehensive unit tests (11 test cases) covering validation, error cases, and success path
  - Added httpx dependency to requirements.txt (required for FastAPI TestClient)
- Frontend development server using Vite
  - Vite configuration with React plugin and TypeScript support
  - Development server runs on `http://localhost:5173` with hot reload
  - TypeScript strict mode enabled
  - Tailwind CSS configured and integrated
  - Environment variable support for API base URL (`VITE_API_BASE_URL`)
  - HTTP message API service implementation (`HttpMessageApiService`)
  - WebSocket URL automatically derived from API base URL
  - Entry point files: `index.html`, `src/main.tsx`, `src/index.css`, `src/env.d.ts`
  - Configuration files: `vite.config.ts`, `tsconfig.json`, `tailwind.config.js`, `postcss.config.js`
  - `package.json` with all required dependencies (Vite, React, TypeScript, Tailwind)
  - Node.js >= 18.0.0 requirement documented
- Frontend-backend integration
  - Health check service (`src/ui/services/healthCheck.ts`) for backend connectivity verification
  - Device API service (`src/ui/services/deviceApi.ts`) for fetching device state from backend
  - Conversation API service (`src/ui/services/conversationApi.ts`) for fetching conversation information
  - Message fetch API service (`src/ui/services/messageFetchApi.ts`) for fetching initial messages
  - Updated `main.tsx` to fetch real data from backend on app startup
  - Automatic health check on app initialization (development logging only)
  - Device state derivation from backend API responses
  - Conversation list derived from messages and conversation info endpoints
  - Message fetching with pagination support
  - Reverse chronological ordering for conversations and messages (newest first)
  - Read-only flags set based on device state
  - WebSocket connection established automatically for real-time message delivery
  - Graceful fallback to mock data if backend is unavailable
  - Error handling with neutral messages (no stack traces or backend details exposed)
- End-to-end message delivery flow
  - Frontend ACK sending when receiving messages via WebSocket
  - Backend ACK forwarding to sender when recipient acknowledges delivery
  - Frontend ACK handling to update message state from PENDING to DELIVERED
  - Complete message lifecycle: Send â†’ Delivery â†’ ACK â†’ UI Update
  - Message state transitions: PENDING â†’ DELIVERED â†’ ACTIVE
  - Automatic UI updates without refresh (optimistic updates + ACK reconciliation)
  - WebSocket-based real-time message delivery and ACK handling
  - REST polling fallback for message delivery (when WebSocket unavailable)
  - Message ordering maintained (reverse chronological, newest first)
- Developer-facing UX instrumentation for manual testing
  - Message state visibility: PENDING messages show italic text with ðŸ• (Queued) indicator, FAILED messages show âš  (Failed) indicator with muted styling
  - Connection status indicator: Shows WebSocket connected/reconnecting, REST polling fallback active in status bar
  - Debug mode toggle: Developer-facing toggle to show message metadata (message ID, state, timestamps) for manual testing
  - UX guardrails: Send button disabled when connection is "connecting" or "disconnected", prevents duplicate sends via rapid clicking
  - Connection status tracking: MessageHandlerService exposes connection status changes via callback for UI indicators
  - Reactive state updates: Message state transitions (PENDING â†’ DELIVERED) are visible immediately without refresh
  - Code quality: Fixed duplicate sender_id assignment in messageStore.ts by explicitly excluding preserved fields from message spread
- Local development connectivity (CORS and WebSocket configuration)
  - CORS middleware enabled for local development (allows `http://localhost:5173` and `http://127.0.0.1:5173`)
  - Environment-aware CORS configuration (permissive in dev, strict in production)
  - REST API endpoints include CORS headers (health check, message receive, etc.)
  - WebSocket endpoint accepts connections from browser origins (device_id via query parameter)
  - All required headers allowed: `Content-Type`, `Authorization`, `X-Device-ID`, `X-Controller-Key`
  - Methods allowed: `GET`, `POST`, `OPTIONS` (CORS preflight support)
  - Device auto-provisioning in development mode (devices automatically registered, provisioned, and activated on WebSocket connection)
  - Production mode requires manual device provisioning via Controller API (strict security)
  - Code quality: Narrowed exception handling from broad Exception to specific ValueError (only exception type raised by device registry methods)
- Heroku deployment support for multi-device live demos
  - Procfile for Heroku backend deployment (uvicorn with --host 0.0.0.0 --port $PORT)
  - Root-level package.json for Heroku Node.js buildpack detection (delegates to src/ui/package.json)
  - .python-version file (Python 3.14.0) for Heroku Python buildpack
  - Backend static file serving for frontend (serves React app from `src/ui/dist/`)
  - CORS configuration supports `FRONTEND_ORIGIN` environment variable for deployed frontend
  - Encryption mode logging at startup (logs active ENCRYPTION_MODE)
  - Frontend uses `window.location.origin` for API base URL (works on any domain)
  - WebSocket URL automatically uses `wss://` for HTTPS origins
  - Device ID generation and persistence (unique per browser, stored in localStorage)
  - Conversation auto-creation on first load (creates conversation if none exists)
  - Conversation join flow UI component (view current ID, paste ID to join from another device)
  - Conversation ID persistence in localStorage (maintains conversation across reloads)
  - Frontend build integration (heroku-postbuild script uses `npm install --include=dev` to ensure devDependencies are installed even when `NODE_ENV=production`)
  - Multi-buildpack support (Node.js for frontend build, Python for backend)
  - .python-version file committed (removed from .gitignore for Heroku Python buildpack)
  - Comprehensive deployment documentation (DEPLOYMENT.md) with step-by-step instructions
  - Live demo checklist for multi-device testing (Chrome â†’ Safari, Laptop â†’ Mobile, etc.)

### Fixed
- Message send endpoint security and validation fixes
  - **Security**: Added authorization check to verify sender is a participant in the conversation before allowing message send (returns 403 Forbidden if not a participant)
  - **Security**: Added future timestamp validation to reject timestamps beyond clock skew tolerance in the future (prevents timestamp manipulation attacks)
  - Fixed conversation existence checking logic bug: Added `conversation_exists()` method to `ConversationRegistry` to properly distinguish between non-existent conversations (404) and closed conversations (400)
  - Fixed logging field name from `payload_size_bytes` to `message_size_bytes` to comply with logging service prohibited key validation (keys containing "payload" are rejected)
  - Fixed conversation validation order to check existence before state (ensures proper 404 vs 400 status codes)
  - Fixed logging service enum usage (changed from string constants to LogEventType enum values to prevent AttributeError)
  - Fixed type hint in `ConversationRegistry.get_conversation_participants()` from `Optional[Set[str]]` to `Set[str]` to match implementation (always returns set, never None)
  - Updated `conversation_api.py` to check for empty set instead of None when checking conversation existence
  - Moved all inline imports to module top (CLOCK_SKEW_TOLERANCE_MINUTES, DEFAULT_MESSAGE_EXPIRATION_DAYS, MAX_MESSAGE_PAYLOAD_SIZE_KB, LogEventType, timedelta, base64)
  - Added unit tests for authorization check (sender not participant) and future timestamp validation
  - Updated unit tests to use LogEventType enum for event type assertions

### Fixed
- Minimal backend HTTP & WebSocket server for local development
  - FastAPI server entrypoint (`src/backend/server.py`) with explicit dependency injection
  - WebSocket connection manager (`src/backend/websocket_manager.py`) for real-time message delivery
  - All API endpoints wired to existing services:
    - Controller API: `/api/device/provision`, `/api/device/provision/confirm`, `/api/device/revoke`
    - Conversation API: `/api/conversation/create`, `/api/conversation/join`, `/api/conversation/leave`, `/api/conversation/close`, `/api/conversation/info`
    - Message API: `/api/message/send`, `/api/message/receive`
    - Logging API: `/api/log/event`
    - WebSocket: `/ws/messages` for real-time message delivery
    - Health check: `/health`
  - Device authentication via `X-Device-ID` header
  - Controller authentication via `X-Controller-Key` header
  - FastAPI and uvicorn dependencies added to `requirements.txt`
  - Clear TODOs for encryption and auth hardening (TLS, rate limiting, etc.)
  - Server runs on `http://0.0.0.0:8000` by default for local development

### Fixed
- Replaced deprecated FastAPI event decorators with modern lifespan context manager
  - Replaced `@app.on_event("startup")` and `@app.on_event("shutdown")` with `lifespan` context manager
  - Uses `@asynccontextmanager` pattern per FastAPI best practices
  - Improves compatibility with modern FastAPI versions
- Critical WebSocket sync/async compatibility issue in backend server
  - Fixed `FastAPIWebSocketManager.send_to_device()` to actually send messages instead of only checking connection existence
  - Implemented message queue and background task for async WebSocket delivery
  - WebSocket messages now properly delivered in real-time instead of falling back to REST polling
  - Background task starts on app startup and stops on shutdown
- Security vulnerability: hardcoded test API key in production code
  - Removed hardcoded `"test-controller-key"` from `ControllerAuthService` initialization
  - Controller API keys now loaded from `CONTROLLER_API_KEYS` environment variable (comma-separated)
  - Falls back to test key only if no environment variable is set (with warning log for development)
  - Added TODO for proper configuration management
- Missing input validation in `/api/message/send` endpoint
  - Added validation for empty recipients list
  - Added validation for payload type (must be string)
  - Added validation for empty payload
  - Improved error messages for each validation failure
- Duplicate documentation in README.md
  - Removed duplicate "Available Endpoints" section
- Controller API state transition error handling
  - Fixed revoke_device() to return 409 Conflict for invalid state transitions instead of 500 Backend Failure
- Frontend-backend integration code quality improvements
  - Removed duplicate device state fetch in `main.tsx` (was fetching twice unnecessarily)
  - Removed redundant message read-only state update (messages already have state set when added to collection)
  - Added `.vite/` and `dist/` directories to `.gitignore` to prevent Vite build artifacts from being committed
- WebSocket resilience and REST polling fallback
  - Created composite transport (`src/ui/services/compositeTransport.ts`) that manages both WebSocket and REST polling
  - Automatic REST polling fallback after 15s WebSocket disconnect (per Resolved Clarifications #51)
  - REST polling stops immediately when WebSocket reconnects (WebSocket is preferred transport)
  - Enhanced WebSocket transport with reconnect logging (development mode only, no content exposed)
  - Message deduplication verified and working correctly (handled by message store)
  - Transport factory updated to use composite transport when both WebSocket and API URLs are available
  - Added comprehensive unit tests for composite transport resilience behavior
  - Updated README.md with WebSocket resilience documentation section
- WebSocket resilience bug fixes
  - Fixed transport switching bug: WebSocket reconnection now properly stops REST polling when polling is active
  - Fixed timer reset issue: Fallback timer no longer resets on reconnection attempts, ensuring fallback activates after 15s total disconnect time
  - Fixed unconditional fallback timer: Timer only schedules if WebSocket is not connected immediately
  - Improved test coverage: Added tests for REST fallback activation, WebSocket reconnection handling, timer reset prevention, and message forwarding from both transports
- Interactive message send path verification and hardening
  - Fixed backend validation: Backend now derives recipients from conversation_id when recipients list is empty (per frontend expectation)
  - Added payload validation: Frontend now validates and trims message content before sending
  - Verified optimistic updates: Messages appear immediately in UI as PENDING state with correct ordering
  - Verified disabled send conditions: Send button properly disabled for neutral enterprise mode, revoked devices, and closed conversations
  - Added comprehensive send path tests: Tests for payload validation, API calls, optimistic updates, failure handling, and delivery subscriptions
  - Updated README.md: Added "Sending Messages (Interactive Path)" section documenting send flow, optimistic updates, failure handling, and disabled conditions
  - Documented ACK handling gap: Backend ACK forwarding is currently a TODO (noted in documentation)
- Fix test bugs in E2E integration tests
  - Fixed utc_now mocking: Added proper mocking in `src.backend.message_relay`, `src.shared.message_types`, and `src.client.message_delivery` modules to ensure deterministic test behavior
  - Fixed message state expectations: Updated tests to expect `ACTIVE` state instead of `DELIVERED` after `receive_message()` (per State Machines #7, Section 3: DELIVERED -> ACTIVE transition)
  - Added device state verification: Explicit checks to ensure devices are in ACTIVE state after `confirm_provisioning()` before testing message relay
  - Fixed frontend test: Added `console.error` logging in `MessageComposer` for development mode when message sending fails (satisfies test expectation while keeping production silent)
  - All backend E2E tests now passing (141/142 â†’ 142/142)
  - All frontend tests now passing (109/110 â†’ 110/110)
- Critical ACK detection bug fix and ACK handling improvements
  - Fixed ACK detection logic in `messageHandler.ts`: Previous logic checked for empty `conversation_id`, but backend sends `conversation_id` in ACK messages, causing ACKs to be treated as regular messages
  - New ACK detection: Checks if `message_id` exists in store with state "sent" and incoming message has `sender_id` matching `device_id` with state "delivered" or "failed"
  - **CRITICAL BUG FIX**: Added missing `get_message_sender()` and `get_message_conversation()` methods to `MessageRelayService` class
    - These methods were referenced in `server.py` but did not exist in the actual file on disk, causing `AttributeError` at runtime when processing ACKs
    - Methods are now properly implemented and accessible, preventing runtime errors in ACK forwarding mechanism
    - Replaced private attribute access (`_pending_deliveries`) with proper public API methods
  - Removed duplicate UI notifications: `updateMessage()` already calls `_notifyUpdate()` internally, removed redundant call in ACK handling path
  - Improved race condition handling: Added comments explaining graceful handling of sender disconnections between connection check and send
  - Enhanced conversation_id handling: Uses `conversation_id` from ACK if provided, otherwise gets from metadata, ensuring it's always included in forwarded ACK
  - ACK flow now works correctly: Recipient sends ACK â†’ Backend forwards to sender (using proper API methods) â†’ Sender correctly detects ACK and updates message state

### Added
- Controller API endpoints for device provisioning and revocation
  - POST /api/device/provision: Creates device in Pending state per Identity Provisioning (#11)
  - POST /api/device/provision/confirm: Transitions Pending â†’ Provisioned per State Machines (#7)
  - POST /api/device/revoke: Revokes device immediately and irreversibly per Identity Provisioning (#11)
  - Controller authentication via API key (X-Controller-Key header) per API Contracts (#10)
  - Controller DTOs and response types (ProvisionDeviceRequest/Response, ConfirmProvisioningRequest/Response, RevokeDeviceRequest/Response)
  - Comprehensive unit tests (19 test cases) covering:
    - Valid state transitions
    - Invalid state transitions
    - Authorization failures
    - Idempotent revoke handling
    - Revocation impact on conversations
  - Controller API documentation with Mermaid diagrams

### Fixed
- Frontend development server improvements
  - Added `node_modules/` to `.gitignore` to prevent committing dependencies
  - Added optional proxy configuration in `vite.config.ts` (commented) for future CORS handling
  - Fixed TypeScript configuration: excluded `vite.config.ts` from main build to prevent compilation errors
  - Verified all Vite setup requirements are met (hot reload, environment variables, type safety)
- Frontend test configuration and test failures
  - Added Vitest configuration (`vitest.config.ts`) with globals enabled and jsdom environment
  - Added test setup file (`src/test-setup.ts`) for `@testing-library/jest-dom` matchers
  - Added missing test dependencies: `@testing-library/react`, `@testing-library/jest-dom`, `jsdom`
  - Converted all test files from Jest to Vitest (replaced `jest.fn()` â†’ `vi.fn()`, `jest.Mocked` â†’ `vi.Mocked`, etc.)
  - Fixed MessagingView test failures: Changed `getByText` to `getAllByText` for elements that appear multiple times (Conversation, device-002, Queued)
  - Fixed messageStore sender preservation: Preserve original `sender_id` when deduplicating messages to prevent sender spoofing
  - Fixed MessageComposer error logging: Added development-only `console.error` logging for send failures
  - All frontend tests now passing (110 tests)
- PR review feedback fix for MessagingView (round 2)
  - Fixed stale closure bug by including deriveConversations in useEffect dependency array
  - deriveConversations depends on isReadOnly, so callback must be re-registered when isReadOnly changes
  - Prevents incorrect conversation states (can_send, send_disabled, is_read_only) when read-only state changes
  - Use functional state updates to avoid dependency on state values
  - Re-subscription only occurs when messageHandler or isReadOnly changes (rare events)

### Added
- Visible messaging UI with store-connected view
  - MessagingView component that subscribes to message store
  - Conversation list derived from message store in real time
  - Message pane displaying messages in chronological order
  - Live updates when store state changes (no duplicate state)
  - Last message preview in conversation list
  - Delivery state indicators (pending/delivered/failed)
  - Lightweight tests for conversation list and message pane updates
  - No reimplementation of message logic (uses existing store)
- Hardened message store with comprehensive TypeScript tests
  - Enhanced message store with bulk add method for reconnection reconciliation
  - Comprehensive test suite covering:
    * Message deduplication logic (by ID, across senders, out-of-order)
    * Ordering with interleaved incoming and outgoing messages
    * Reconnection reconciliation (missed messages, duplicates, overlapping timestamps)
    * Delivery state transitions (prevent regression, allow valid transitions)
    * Transport switching behavior (WebSocket â†” REST polling, no duplicates, no dropped messages)
    * Stable ordering guarantees (server timestamp-based, not insertion order)
  - All tests use deterministic timestamps and IDs
  - No DOM rendering required (pure unit tests)
  - Tests run fast and deterministically

### Fixed
- PR review feedback fixes for incoming message handling
  - Fixed state reconciliation logic to handle all state transitions correctly:
    * delivered â†’ failed (delivery failure after initial success)
    * any â†’ expired (expiration can happen at any time)
    * delivered â†’ delivered (allow metadata updates for messages in final state)
    * failed â†’ failed (allow metadata updates for messages in final state)
  - Fixed React dependency array stale closure risk using refs for callbacks
  - Fixed performance issue: excluded initialMessagesByConversation from deps to avoid recreating handler
  - Removed overly defensive try-catch (getMessages doesn't throw)
  - Added comprehensive tests for all state transitions including metadata updates

### Added
- Incoming message handling and live updates
  - Transport abstraction layer (WebSocket + REST polling)
  - WebSocket transport implementation with automatic reconnection
  - REST polling transport fallback (30-second interval)
  - Message store with deduplication and ordering
  - Message handler service coordinating transport and store
  - State reconciliation (merge without overwriting incorrectly)
  - Automatic UI updates when new messages arrive
  - Connection lifecycle handling (connect/disconnect/reconnect)
  - Reconnection reconciliation (missed messages fetched on reconnect)
  - Comprehensive unit tests for deduplication and reconnection
  - Transport factory for creating appropriate transport
  - No content logged or leaked per deterministic rules
  - Messages appear automatically without page reload
  - Preserves reverse chronological ordering
  - Handles expired message cleanup automatically

### Fixed
- PR review feedback fixes for interactive messaging
  - Removed console.error logging in MessageComposer (violates "no content logged or leaked" rule)
  - Removed unused handleDeliveryUpdate callback in App.tsx (delivery updates handled via subscription)
  - Simplified delivery state transition handling
  - Updated README.md with local development instructions (backend and frontend)

### Added
- Interactive messaging (send path only)
  - MessageComposer component for message composition and sending
  - SendButton component with disabled states and sending indicator
  - MessageApiService interface for client-side message sending
  - Optimistic updates (message enters PENDING state immediately)
  - Delivery state transitions (PENDING â†’ DELIVERED, PENDING â†’ FAILED)
  - Visual indicators for pending (queued), delivered, and failed messages
  - State handling for pending messages and delivery updates
  - API integration using existing adapters
  - Comprehensive unit tests for send path components
  - Sending disabled when: neutral enterprise mode, revoked device, or closed conversation
  - No retry controls exposed in UI per constraints
  - No content logged or leaked per deterministic rules
- Read-only UI shell (React + TypeScript + Tailwind CSS)
  - React components for read-only message and conversation display
  - StatusIndicator component for device state display
  - ConversationList component for active conversations
  - MessageList component with reverse chronological ordering
  - MessageRow component with visual distinction for states
  - App component orchestrating the UI shell
  - TypeScript types mirroring Python UI domain models
  - Tailwind CSS styling with neutral, enterprise-safe visual tone
  - Mock data fixtures for Storybook-style testing
  - Unit tests for rendering, ordering, and neutral mode enforcement
  - No sound, no animation, no urgency cues per UX Behavior (#12)
  - Visual distinction for delivered/failed/expired messages
  - Read-only mode indicators for neutral enterprise mode
- UI domain adapter layer
  - UI domain models (view models) per UX Behavior (#12)
  - MessageViewModel with derived UX flags (is_expired, is_failed, is_read_only)
  - ConversationViewModel with derived UX flags (can_send, is_read_only, send_disabled)
  - ParticipantViewModel for participant display
  - DeviceStateViewModel with derived permission flags
  - UIAdapter mapping client API DTOs to UI domain models
  - Deterministic derivation of UX flags from API responses
  - Reverse chronological sorting (newest first per Resolved Clarifications #53)
  - Message filtering (expired, failed, active conversations)
  - Neutral enterprise mode support (read-only flags per Resolved Clarifications #38)
  - Comprehensive unit tests (14 test cases, all passing)
  - UI domain adapter layer diagrams (Mermaid)
- Client-facing API boundary and adapter layer
  - Client-facing API response schemas (DTOs) per API Contracts (#10)
  - API adapter layer mapping internal models to client DTOs (UX Behavior #12, Section 3.6)
  - Error code enumeration and mapping (API Contracts #10, Section 6)
  - API versioning strategy (v1 per API Contracts #10)
  - State mapping (internal states â†’ client-visible states per UX Behavior #12, Section 4)
  - Error normalization pipeline (neutral messages per Copy Rules #13, Section 4)
  - Content-free error responses (no internal details, stack traces, or sensitive info)
  - Comprehensive unit tests (15 test cases, all passing)
  - API boundary and adapter layer diagrams (Mermaid)
- Logging, observability, and audit enforcement
  - Structured logging utilities with JSON format (Logging & Observability #14, Section 2)
  - Content-free logging validation (no message content, keys, or sensitive data per Logging & Observability #14, Section 4)
  - LoggingService with log retention and purge enforcement (90 days per Resolved TBDs)
  - Audit event model and recorder (append-only, immutable per Data Classification #8, Section 3)
  - MetricsService with 1-hour aggregation windows (Resolved TBDs)
  - Alert threshold logic (â‰¥5 failed deliveries in 1-hour window per Resolved TBDs)
  - Metrics instrumentation for: active devices, messages queued, failed deliveries, revoked devices
  - Comprehensive unit tests (12 test cases, all passing)
  - Observability and audit enforcement diagrams (Mermaid)
- Device identity and revocation enforcement
  - Device identity state model (Pending, Provisioned, Active, Revoked per State Machines #7, Section 5)
  - DeviceRegistry service with identity state tracking (Identity Provisioning #11)
  - Identity enforcement service with server-side permission checks (Functional Spec #6, Section 3.2)
  - Revocation handling logic (immediate and irreversible per Identity Provisioning #11, Section 5)
  - Key rotation trigger handling (every 90 days or immediately upon revocation per Resolved TBDs)
  - Server-side enforcement for message sending, conversation creation/join (Resolved Clarifications #38)
  - Neutral enterprise mode support (revoked devices can read but cannot send/create/join)
  - Revocation impact handling (removes device from all conversations per State Machines #7, Section 4)
  - Comprehensive unit tests (17 test cases, all passing)
  - Device identity lifecycle diagrams (Mermaid)
- Backend conversation API service
  - POST `/api/conversation/create` - Create conversation with permission enforcement (Functional Spec #6, Section 4.1)
  - POST `/api/conversation/join` - Join conversation with group size validation (max 50 per Resolved TBDs)
  - POST `/api/conversation/leave` - Leave conversation (closes if last participant per State Machines #7, Section 4)
  - POST `/api/conversation/close` - Close conversation (participants only)
  - GET `/api/conversation/info` - Get conversation information (supports neutral enterprise mode per Resolved Clarifications #38)
  - Permission enforcement (only provisioned devices may create/join per Identity Provisioning #11)
  - Group size limit enforcement (max 50 participants, checked before join)
  - Conversation state validation (cannot join closed conversations)
  - Neutral enterprise mode support (revoked devices can view but cannot create/join)
  - Comprehensive unit tests (16 test cases, all passing)
  - Conversation API lifecycle diagrams (Mermaid)
- Core message delivery module implementation
  - Message creation, encryption, and delivery (Functional Spec #6, Sections 4.2-4.5)
  - Message lifecycle state machine (State Machines #7, Section 3)
  - Offline queuing with storage limits (max 500 messages/50MB per Resolved TBDs)
  - Message expiration enforcement (default 7 days, device-local timers)
  - Duplicate detection (Message ID + content hash per Resolved Clarifications)
  - Retry logic with limits (max 5 attempts per Resolved TBDs)
  - WebSocket and REST delivery mechanisms (Resolved TBDs)
- Conversation management module implementation
  - Conversation creation with explicit participant definition (Functional Spec #6, Section 4.1)
  - Conversation lifecycle state machine (Uncreated â†’ Active â†’ Closed per State Machines #7, Section 4)
  - Participant addition and removal with group size enforcement (max 50 per Resolved TBDs)
  - Conversation closure handling (all messages remain until expiration per Resolved Clarifications)
  - Participant revocation handling (removes from all conversations, closes if all revoked)
  - Neutral enterprise mode support (read-only for revoked devices per Resolved Clarifications)
  - Active conversation retrieval sorted by last message timestamp (UX Behavior #12)
  - Integration with message delivery module (conversation state checks)
- Backend conversation registry service
  - Conversation membership tracking (Restricted classification per Data Classification #8)
  - Participant management and revocation handling
  - Conversation closure and cleanup
- Backend message relay service
  - Encrypted message relay (no plaintext storage per Functional Spec #6, Section 5.1)
  - WebSocket and REST delivery support
  - Expiration enforcement
  - Metadata handling (Restricted classification per Data Classification #8)
- Shared types and constants
  - Message data structures and state enums
  - Conversation data structures and state enums
  - Constants from resolved TBDs and clarifications
  - UTC time helper function (timezone-aware)
- Message delivery reliability hardening
  - ACK handling per message ID with timeout (30s per Resolved Clarifications #51)
  - Exponential backoff retry policy (base * 2^retry_count, max 60s per Lifecycle Playbooks #15)
  - WebSocket reconnect with exponential backoff (Resolved Clarifications #51)
  - REST polling fallback (every 30s when WebSocket unavailable per Resolved TBDs #18)
  - Enhanced retry logic with exponential backoff for offline queue processing
  - Expired message rejection enforcement (Functional Spec #6, Section 4.4)
  - Duplicate message suppression (Message ID + content hash per Resolved Clarifications #35)
- Comprehensive unit tests
  - 13 test cases for UI domain adapter layer (all passing)
  - 15 test cases for API adapter layer (all passing)
  - 12 test cases for logging, observability, and audit enforcement (all passing)
  - 18 test cases for device identity and revocation enforcement (all passing)
  - 16 test cases for backend conversation API (all passing)
  - 12 test cases for message delivery reliability hardening (all passing)
  - 18 test cases for conversation management (all passing)
  - 13 test cases for message delivery (all passing)
  - Test coverage for critical paths
  - Timer cleanup in test teardown to prevent pytest hanging
- Project infrastructure
  - pytest.ini configuration
  - setup.py for development installation
  - .gitignore with Python and project-specific ignores
  - requirements.txt with dependencies
  - Package structure with __init__.py files
- Documentation
  - UI domain adapter layer diagrams (Mermaid)
  - API boundary and adapter layer diagrams (Mermaid)
  - Observability and audit enforcement diagrams (Mermaid)
  - Device identity lifecycle diagrams (Mermaid)
  - Conversation API lifecycle diagrams (Mermaid)
  - Message lifecycle diagrams (Mermaid)
  - Conversation lifecycle diagrams (Mermaid)
  - Message delivery reliability diagrams (Mermaid)
    - Delivery lifecycle with ACK
    - Retry & failure state transitions
    - WebSocket reconnect & REST fallback flow
    - Exponential backoff retry flow
    - REST polling message processing
    - ACK timeout handling
  - Client module README
  - Top-level documentation files (README.md, LICENSE.md, CONTRIBUTING.md, CHANGELOG.md, ROADMAP.md)

### Changed
- **Code Quality Improvements** (Project Best Practices #20)
  - Added comprehensive type hints per PEP 484 to all functions and classes
  - Added complete docstrings per PEP 257 with Args, Returns, and Raises sections
  - Created Protocol interfaces for abstracted services (EncryptionService, StorageService, WebSocketClient, HttpClient, LogService, DeviceRegistry, WebSocketManager)
  - All public methods, arguments, and return types fully annotated
  - Enhanced docstrings explaining behavior, arguments, return values, and exceptions

### Fixed
- Timer threads now properly cleaned up in test teardown to prevent pytest hanging
- Conversation participant addition now returns False (instead of raising ValueError) for closed conversations
- Timer threads set as daemon threads to allow clean process exit
- HttpClient Protocol missing get() method definition (added to match REST polling usage)
- DeviceRegistry missing provision_device() method for Pending â†’ Provisioned transition (added to complete API surface)

### Technical Improvements
- Use timezone-aware datetime (utc_now() helper) to resolve deprecation warnings
- All code follows Repo & Coding Standards (#17) and Project Best Practices (#20)
- Comprehensive inline documentation with spec references
- Full type safety with Protocol-based interfaces
- No linting errors
- Proper thread cleanup in tests
- Deterministic message delivery with ACK tracking and exponential backoff
- Robust WebSocket/REST fallback mechanism with automatic reconnection

## [0.1.0] - 2024-XX-XX

### Added
- Initial project structure
- Frozen specifications (Assets #1-#18)
- Resolved TBDs and clarifications (27 TBDs + 6 clarifications)
- Core message delivery module
- Project documentation

---

## Version History

- **0.1.0**: Initial release with core message delivery module

## Notes

- All changes must reference relevant specification IDs
- Breaking changes will be clearly marked
- Security-related changes will be highlighted
- All implementations follow frozen specifications (Assets #1-#18)
